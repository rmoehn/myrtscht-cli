#!/usr/bin/perl

# all the nice modules
use strict;
#use warnings;
use Log::Log4perl qw/ :easy /;
use Cwd;
use File::Spec;
use Getopt::Long qw/ :config no_ignore_case bundling /;
use Games::Tournament::RoundRobin;
use Net::CUPS;
use Net::CUPS::Destination;

# set up all the nice options
our %Options;
GetOptions(
        's'   => \$Options{s},
        'a'   => \$Options{a},
        'p'   => \$Options{p},
        'r:s' => \$Options{r},
        'g:s' => \$Options{g},
        'n:s' => \$Options{n},
        'd:s' => \$Options{d},
        'P:s' => \$Options{P},
);

# set up some general variables
my $Etcpath = File::Spec->catfile(
        File::Spec->rootdir(),
        qw/ home moses Perl Myrtscht etc /);

# initialize the logger or not
if (defined $Options{d}) {
    my $cwd = getcwd()
        or die "Couldn't get the current working directory: $!\n";
    my $logfile =
        $Options{d} ?
        File::Spec->catfile($cwd, $Options{d}) :
        File::Spec->catfile($Etcpath, 'log.conf');
    Log::Log4perl->init($logfile);
}
INFO "Initialized.";

# little debbugging help
foreach my $option (keys %Options) {
    DEBUG "Set option $option to $Options{$option}."
        if defined $Options{$option};
}

# invoke the subroutines corresponding to the options
if (defined $Options{n}) {
    INFO "Invoking subroutine to create new tournament.";
    &create_new_tournament(\$Etcpath, \%Options, \@ARGV);
} elsif (defined $Options{p}) {
    INFO "Invoking subroutine to process the group files.";
    &process_group_files(\$Etcpath, \%Options, \@ARGV);
} elsif (defined $Options{a}) {
    INFO "Invoking subroutine to preprocess the game files.";
    &preprocess_game_files(\$Etcpath, \%Options, \@ARGV);
}

# the subroutine invoked if the option -n is defined
sub create_new_tournament {
    my $etcpath               = shift;
    my $options               = shift;
    my $specified_groupfnames = shift;

    # creating the directory in which the tournament is stored
    {
    my @date           = (localtime)[4,3,5];
    my $tournam_dir = 
        $options->{n} || sprintf(
                "Tournament-%02d%02d%d",
                map($_ + 1,  @date[0,1]),
                $date[2] + 1900);
    mkdir($tournam_dir, 0755)
        or die "Couldn't make directory $tournam_dir: $!\n";
    DEBUG "Generated new tournament directory: $tournam_dir.";
    chdir $tournam_dir
        or die "Couldn't change into directory $tournam_dir: $!\n";
    DEBUG "Changed into directory $tournam_dir.";
    }
   
    # write the group template into all the group files
    my $groupnr = $options->{g} || 10;
    my @groupfiles;
    for (my $i = 1; $i <= $groupnr; $i++) {
        my $groupfname = sprintf("%02d.g", $i);
        open(GROUPFILE, ">", $groupfname)
            or die "Couldn't open $groupfname: $!\n";
        print GROUPFILE <<"EOF";
Name:
Tables:
Members:

EOF
    
    DEBUG "Wrote template to group file: $groupfname";
    }
    INFO "Created the group files.";
}

# the subroutine invoked if the option -p is defined
sub process_group_files {
    my $etcpath    = shift;
    my $options    = shift;
    my $groupfiles = shift;
    my $cwd        = getcwd;

    # We have to compute some things therewith the printout looks
    # nice later.
    # The number of lines per sheet of A4 paper must be 67 and 67
    # must be the number of lines per sheet of A4 paper as thou have
    # to use A4 paper with a number of 13 chars per column to get 
    # nice results.
    my $maxsetnr        = ($options->{r} || 2) * 2 - 1;
    my $gamesheetheigth = $maxsetnr + 6;
    my $gamesheets      = sprintf("%d", 67 / $gamesheetheigth);
    my $newlines        = 67 - $gamesheets * $gamesheetheigth;
    DEBUG "There will be $gamesheets per page, so we have to insert "
        . "$newlines newlines after them. They are $gamesheetheigth "
        . "lines high.";

    # the format for the printout; Alas, I can't declare the
    # variables in a smaller scope.
    my($groupname, $member1, $id, $table, $member2, $roundcnt);
    my $printoutform = 
          "format GAMEPRINT = \n"
        . 'Group: @' . '<' x 36 . "\n"
        . '$groupname' . "\n"
        . 'Round: @<<<< Table: @<<<<' . ' ' x 10 . 'ID: @<<<<' . "\n"
        . '$roundcnt, $table, $id' . "\n"
        . '-' x 22 . '+' . '-' x 21 . "\n"
        . '@' . '|' x 20 . ' |' . '@' . '|' x 20 . "\n"
        . '$member1, $member2' . "\n"
        . '-'  x 22 . '+' . '-' x 21 . "\n"
        . (' ' x 22 . '|' . ' ' x 21 . "\n") x $maxsetnr
        . '-'  x 22 . '+' . '-' x 21 . "\n"
        . ".\n";
    DEBUG $printoutform if defined $options->{d};
    eval $printoutform;
    die $@ if $@;

    # process the group files one by one
    foreach my $groupfile (@$groupfiles) {
        my $printfile = "gamesheets";
        my $groupfnr = substr($groupfile, 0, 2);
        my $printer;

        # manage the group directory
        {
        my $groupdir = $groupfnr . ".d";
        mkdir($groupdir, 0755)
            or die "Couldn't make directory $groupdir: $!\n";
        rename($groupfile, File::Spec->catfile($groupdir, $groupfile))
            or die "Couldn't move $groupfile to $groupdir: $!\n";
        chdir $groupdir
            or die "Couldn't change into $groupdir: $!";
        DEBUG "Now in group directory $groupdir.";
        }

        # read the groupfile
        open(GROUPFILE, "<", $groupfile)
            or die "Couldn't open group file $groupfile: $!\n";
        chomp(my @gf_content = <GROUPFILE>);
        close GROUPFILE;
        DEBUG "Group file content: @gf_content";
        $groupname  = substr(shift @gf_content, 6);
        DEBUG "The group is named $groupname.";
        my @tables  = split(m([ ,;.:/]+), substr(shift @gf_content, 8));
        DEBUG "It plays at the tables @tables.";
        shift @gf_content;
        my @members = @gf_content;
        DEBUG "It consists of @members.";
        undef @gf_content;

        # initialize the printing things
        # invoke the spooler or not
        unless (defined $options->{s}) {
            my $cups = Net::CUPS->new()
                or warn "Couldn't get a nice CUPS - we "
                      . "won't be able to print.\n";
            $printer = $cups->getDestination($options->{P})
                or warn "Couldn't get your printer's destination: "
                      . "You have to specify another.\n";
            $printer->addOption("cpi", 13);
            $printer->addOption("columns", 2);
        } 
        open(GAMEPRINT, ">>", $printfile)
            or die "Couldn't open $printfile: $!\n";
        select((select(GAMEPRINT), $|++)[0]);

        # create the schedule for the group
        my @schedule;
        {
        DEBUG "The schedule:";
        my $group = Games::Tournament::RoundRobin->new(
                league => \@members
                );
        for (my $i = 1; $i <= $group->rounds(); $i++) {
            my %round;
            my %raw_schedule = %{ $group->membersInRound($i) };
            DEBUG "Round $i.";
            my %parsed_values;
            foreach my $member (keys %raw_schedule) {
                next if $member eq "Bye";
                next if $raw_schedule{$member} eq "Bye";
                next if $parsed_values{$member};
                $round{$member} = $raw_schedule{$member};
                $parsed_values{$round{$member}} = 1;
            }
            push(@schedule, \%round);
            DEBUG "@schedule";
        }
        }

        # process the schedule and create the necessary files
        {
        my($gamecnt, $appendcnt);

        for my $round (@schedule) {
            $roundcnt++;
            for my $member (keys %{ $round }) {
                $id      = $groupfnr . ++$gamecnt;
                $table   = shift @tables;
                $member1 = $member;
                $member2 = $round->{$member};
                my $gamefile = sprintf("%02d.s", $gamecnt);
                push(@tables, $table);

                # create the gamefile
                open(GAMEFILE, ">", $gamefile)
                    or die "Couldn't open $gamefile: $!\n";
                print GAMEFILE "$member | $round->{$member}\n";

                # append to the print file
                write GAMEPRINT;
                $appendcnt++;
                if ($appendcnt == $gamesheets) {
                    print GAMEPRINT "\n" x $newlines;
                    $appendcnt = 0;
                }
            }
        }
        }

        # print out or do something else
        unless (defined $options->{s}) {
            $printer->printFile($printfile, $printfile)
                or die "Couldn't print out: $!\n";
            unlink $printfile
                or warn "Couldn't remove $printfile: $!\n";
        }

        chdir $cwd
            or die "Couldn't change into $cwd: $!\n";
        DEBUG "Back in $cwd.";
    }
    INFO "Created the schedule.";
}

# the subroutine invoked if the option -a is defined
# But it just preprocesses and gives the the files directly to the
# true processing subroutine.
sub preprocess_game_files {
    my $etcpath         = shift;
    my $options         = shift;
    my $file_containing = shift;

    # process the input and filtering out just the game files to
    # give to the following routine
    if (-d $file_containing->[0]) {
        DEBUG "We have a directory with game files given.";
        my $dirname = $file_containing->[0];
        opendir(GROUPDIR, $file_containing->[0])
            or die "Couldn't open $file_containing->[0]: $!\n";
        @$file_containing = readdir GROUPDIR;
        close GROUPDIR;
        chdir $dirname
            or die "Couldn't change into $dirname: $!\n";
    } else {
        DEBUG "We have a list of game files given.";
    }
    my @gamefiles = grep { /.s$/ } @$file_containing;
    DEBUG "Giving game files @gamefiles to the game file processor.";
    &process_game_files($etcpath, $options, \@gamefiles);
}

# process the game files
sub process_game_files {
    my $etcpath   = shift;
    my $options   = shift;
    my $gamefiles = shift;
    my %players;

    # process the game file and create the data structure
    for my $gamefile (@$gamefiles) {
        open(GAMEFILE, $gamefile)
            or die "Couldn't open game file $gamefile: $!\n";
        my($name1, $name2);
        my $numcont;

        while (<GAMEFILE>) {
            chomp;
            next if /#/;
            if (/(.+) \| (.+)/) {
                ($name1, $name2) = ($1, $2);
                 DEBUG "The players are $name1 and $name2.";
                 $numcont = 0;
            } else {
                ($players{$name1}{balls}, $players{$name2}{balls})
                    = /(\d+)\D+(\d+)/;
                DEBUG "Result: $1 : $2";
                $numcont = 1;
            }

            $players{$name1}{all_fails} += $players{$name2}{balls},
            $players{$name2}{all_fails} += $players{$name1}{balls},
            $players{$name1}{all_balls} += $players{$name1}{balls},
            $players{$name2}{all_balls} += $players{$name2}{balls},
            $players{$name1}{ball_difference} +=
              ($players{$name1}{balls} - $players{$name2}{balls}),
            $players{$name2}{ball_difference} +=
              ($players{$name2}{balls} - $players{$name1}{balls}),
                if $numcont;

            if ($numcont and
                    $players{$name1}{balls} > $players{$name2}{balls}) {
                $players{$name1}{sets_won}++;
                $players{$name1}{all_sets_won}++;
                $players{$name2}{sets_lost}++;
                $players{$name2}{all_sets_lost}++;
            } elsif ($numcont) {
                $players{$name2}{sets_won}++;
                $players{$name2}{all_sets_won}++;
                $players{$name1}{sets_lost}++;
                $players{$name1}{all_sets_lost}++;
            }
            $players{$name1}{balls} = 0; # Just for this game
            $players{$name2}{balls} = 0; #
        }

            if ($players{$name1}{sets_won}
                    > $players{$name2}{sets_won}) {
                $players{$name1}{wins}++;
                $players{$name2}{losts}++;
            } else {
                $players{$name2}{wins}++;
                $players{$name1}{losts}++;
            }

            $players{$name1}{set_difference} +=
              ($players{$name1}{sets_won} - $players{$name2}{sets_won});
            $players{$name2}{set_difference} +=
              ($players{$name2}{sets_won} - $players{$name1}{sets_won});

            $players{$name1}{sets_won} = 0; # Just for this game.
            $players{$name2}{sets_won} = 0; #
    }
    # I know, this whole thing is very very ugly. But how ugly
    # would it be  if there were no hashes? On top of that it
    # produces occasional warnings. But I think, if it
    # wouldn't produce occasional warnings, it would also be
    # far more ugly.
    close GAMEFILE;
    INFO "Processed the game files.";

    # sort the people according to their games
    my @ranking = sort {
        $players{$b}{wins}           <=> $players{$a}{wins}           or
        $players{$a}{losts}          <=> $players{$b}{losts}          or
        $players{$b}{set_difference} <=> $players{$a}{set_difference} or
        $players{$b}{ball_difference} <=> $players{$a}{ball_difference}
    } keys %players;
    DEBUG "Sorted all the stuff.";
    
    # generate the ranking file
    open(RANKING, ">", "ranking")
        or die "Couldn't open \"ranking\" for writing: $!\n";
    printf RANKING ("%4s %-21s\t%-11s\t%-11s\t%-5s\t%-11s\t%-5s\n",
            "Rank", "Name", "Games", "Sets", "SD", "Balls", "BD");
    my $rank;
    foreach my $player (@ranking) {
        printf RANKING (
                    "%3d. %-21s\t%4d : %4d\t%4s : %4s\t%5s\t"
                  . "%4s : %4s\t%5s\n",
                    ++$rank, $player,
                    $players{$player}{wins}            || 0,
                    $players{$player}{losts}           || 0,
                    $players{$player}{all_sets_won}    || 0,
                    $players{$player}{all_sets_lost}   || 0,
                    $players{$player}{set_difference}  || 0,
                    $players{$player}{all_balls}       || 0,
                    $players{$player}{all_fails}       || 0,
                    $players{$player}{ball_difference} || 0,
                    );
    }
    INFO "Generated the ranking file.";
}

__END__

=encoding utf8

=head1 NAME

myrtscht - My Round robin Tournament SCHeduling for Table tennis



=head1 SYNOPSIS

myrtscht B<-n> [I<name>] [B<-g> I<number>] [B<-d> [I<file>]]

myrtscht B<-p> I<files> [B<-r> I<rounds>] [B<-s>] [B<-P> I<printer>] [B<-d> [I<file>]]

myrtscht B<-a> I<files>/I<directory> [B<-d> [I<file>]]

myrtscht B<--help>

myrtscht B<-h>



=head1 DESCRIPTION

B<myrtscht> is a program which helps you managing table tennis
tournaments with the round robin system.  But I think, you can also
use it for other games.  It is completely text and command based, so
there is neither a CLI nor a GUI, my apologies for this (if this needs
to be apologised).  Therefore it works, as you can see in the
synopsis, with running commands and editing text files.



=head1 OPTIONS AND ARGUMENTS

=over

=item B<-n> [I<name>]

Creates a new directory used for the tournament with the group files in
it.  You can also give the directory a name, which has no effects on the
group files, the default is "Tournament-<date>".

=item B<-g> I<number>

Defines the number of group files created when running with B<-n>, the
default is 10.

=item B<-p> I<files>

Creates a group directory with the game files in it from each of the
I<files> given and prints out some nice formatted tables on sheets of
paper where you can write down the results of the games.

=item B<-r> I<sets>

Defines the number of sets to win for winning the whole game, the
default is 2.  This is required when running with B<-p>.

=item B<-s>

Disables printing when running with B<-p>.

=item B<-P> I<printer>

Defines the I<printer> used when running with B<-p>, the default is the
standard printer.

=item B<-a> I<files>/I<directory>

Computes a ranking file from the given group I<files> or I<directory>.

=item B<-d> [I<file>]

Switches to debugging mode.  The log is created by using the
L<Log::Log4perl(3)|Log::Log4perl> module.  You can specify a config 
I<file> to modify the output.

=item B<-h> or B<--help>

Print this help.

=back



=head1 FILES

B<myrtscht> creates different files in its process of working.  They all
have a special extension.  These may show up:

=head2 The Tournament Directory

The tournament directory is the directory all information for on
tournament are stored in.  It is recommended to stay in this or
subordinated directories when working with B<myrtscht>.


=head2 Group Files F<*.g>

These are the files you are going to see first when running a
tournament.  Their format (before editing) is:

    Name:
    Tables:
    Members:

Z<>
Behind "Name: " you have to write the name of the group.  Behind
"Tables: " the names of the tables (numbers are recommended) the group
plays at stand in a comma separated list. (Yes there are also other
separators possible.  Look in the source code if you want them 
implicitly!)  I<Under> "Members:" you have to write the names of the
members of the group.

=head3 Example:

    Name: 50 before Christ
    Tables: 1, 2, 3
    Members:
    Asterix
    Obelix
    Gaius Iulius Caesar
    Gaius Bonus

=head3 Note:

Names with more than 20 letters are unbearable. (Maybe also the
parents of the persons with this names.)


=head2 The Group Directories F<*.d>

Group directories are created when running B<myrtscht> with the option
B<-p>.  They are named like the group files they are belonging to
(apart from the extension).  All things belonging to one group should
be done within the particular directory, so the group file is moved
into the directory when running with B<-p>.


=head2 Game Files F<*.s>

These are the files being in a group directory after running with B<-p>.
They look like this (before editing):

    Asterix | Gaius Iulius Caesar

There you can write down the results of a match.

=head3 Example:

    Asterix | Gaius Iulius Caesar
    11  8
    10  12
    11  9

=head3 Note:

It is recommended to use just whitespace between the numbers.


=head2 The Printout/F<gamesheets>

When running B<myrtscht> with the option B<-p> it creates the file
F<gamesheets>, sends it to the printer and then removes it.  If B<-s> is
defined, there will be no printing and no removing.  With both versions
parts of the printout will have this format (here just an example):
 
    Group: 50 before Christ
    Round: 2     Table: 3              ID: 013
    ----------------------+---------------------
           Asterix        | Gaius Iulius Caesar
    ----------------------+---------------------
                          |
                          |
                          |
    ----------------------+---------------------

Each of this parts represents one game.  Behind "Group: " is the name of
the group situated.  "Round: " is the round they play in, "Table: " the
name of the table they play at.  The "ID" is formed out of the names of
the group directory (first two digits) and the game file (last one
through three digits).  So you can easily identify the game file
belonging to this game sheet.  Then the names of the opponents come and
in the space below the referee can write down the result of the match.
The width of this spaces varies with the number of rounds to play to win
a match.


=head2 The Ranking File F<ranking>

Here the results of a group are written down.  You can see an example
down below, but in order to work also with high scores it is a bit wide.

    Rank Name                   Games       Sets        SD      Balls       BD   
      1. Asterix                   3 :    0    6 :    1     5     76 :   53    23
      2. Gaius Iulius Caesar       2 :    1    5 :    3     2     82 :   62    20
      3. Obelix                    1 :    2    3 :    4    -1     59 :   57     2
      4. Gaius Bonus               0 :    3    0 :    6    -6     21 :   66   -45

"Rank" and "Name" are unambiguous.  "Games", "Sets" and "Balls"
represent the played games, sets, respectively balls in the format
"won : lost".  SD and BD represent the difference between won and lost
sets, respectively balls.



=head1 A BIG EXAMPLE or TUTORIAL (as you like it)

Since all the stuff above is very theoretical, I will give a big
example of the order of events in a tournament. You can see this part
also as a tutorial wich makes getting used to B<myrtscht> easy.

So let us start: Imagine, we are the organizers of a yearly table
tennis tournament and we have heared from B<myrtscht>. Luckily we
have a computer, we install the program and look forward to the
event, since it will not become such tremendous arduous like the last
years because of having B<myrtscht>. Unfortunately the person
responsible for advertising has become ill and now there are just
eleven persons to play. Wherever! Iulius Caesar is here and we do not
want to disappoint him.

But now let's begin working with our new tool!

Firstly we init the tournament:

    $ myrtscht -n Aremorican_Open-50BC -g 2
    $ cd Aremorican_Open-50BC
    $ ls
    01.g  02.g

There have four women and seven men registered at your table, so we
make two groups out of them 


=head1 NOTES

If there are some mistakes in my grammar or spelling - please excuse.

If anybody does not my like my way to document - please write me.



=head1 BUGS

When printing letters with umlaut in formats the layout gets a bit
crazy, because the umlauts are counted like two but printed like one
letter. - I think, this is a common problem, but haven't found a
solution.  Maybe anyone reading this will give me a hint.

When finding some other bugs write to my e-mail address.  There will
also be a website and I want to upload this program to
L<GNU Savannah|http://savannah.nongnu.org>.  So there is hope for a real
bug tracker.



=head1 SEE ALSO

L<Games::Tournament::RoundRobin>, L<Log::Log4perl>

There will also be a web site when I find time for it (maybe in summer).
But the current version is always available from
L<www.myrtscht.de|http://www.myrtscht.de>.



=head1 AUTHOR

Richard Möhn E<lt>richard.moehn@gmx.deE<gt>



=head1 COPYRIGHT AND LICENSE

Copyright 2008 by Richard Möhn E<lt>richard.moehn@gmx.deE<gt>

This program is free software.  You may copy or redistribute it under
the same terms as Perl itself.

=cut
