#!/usr/bin/perl

# all the nice modules
use warnings;
use strict;
use Log::Log4perl qw/ :easy /;
use Cwd;
use File::Spec;
use File::Temp;
use Getopt::Long qw/ :config no_ignore_case bundling /;
use Games::Tournament::RoundRobin;
use Net::CUPS;
use Net::CUPS::Destination;

# set up all the nice options
our %Options;
GetOptions(
        's'   => \$Options{s},
        'a'   => \$Options{a},
        'p'   => \$Options{p},
        'b:s' => \$Options{b},
        'r:s' => \$Options{r},
        'g:s' => \$Options{g},
        'n:s' => \$Options{n},
        'd:s' => \$Options{d},
        'o:s' => \$Options{o},
        'P:s' => \$Options{P},
);

# set up some general variables
my $Etcpath = File::Spec->catfile(
        File::Spec->rootdir(),
        qw/ home moses Perl Myrtscht etc /);
my $Printer;

# initialize the logger or not
if (defined $Options{d}) {
    my $cwd = getcwd()
        or die "Couldn't get the current working directory: $!\n";
    my $logfile =
        $Options{d} ?
        File::Spec->catfile($cwd, $Options{d}) :
        File::Spec->catfile($Etcpath, 'log.conf');
    Log::Log4perl->init($logfile);
}
DEBUG "Initialized.";

# little debbugging help
foreach my $option (keys %Options) {
    DEBUG "Set option $option to $Options{$option}."
        if defined $Options{$option};
}

# invoke the spooler or not
if (defined $Options{"p" or "a" or "o"} and !defined $Options{s}) {
    my $cups = Net::CUPS->new()
     or warn "Couldn't get a nice CUPS - we won't be able to print.\n";
    $Printer = $cups->getDestination($Options{P})
     or warn "Couldn't get your printer's destination: You have to specify another.\n";
} 

# invoke the subroutines corresponding to the options
if (defined $Options{n}) {
    DEBUG "Invoking subroutine to create new tournament.";
    &create_new_tournament(\$Etcpath, \%Options, \@ARGV);
} elsif (defined $Options{p}) {
    DEBUG "Invoking subroutine to process the group files.";
    &process_group_files(\$Etcpath, \%Options, $Printer, \@ARGV);
} elsif (defined $Options{a}) {
    DEBUG "Invoking subroutine to preprocess the game files.";
    &preprocess_game_files(\$Etcpath, \%Options, \@ARGV);
}

# the subroutine invoked if the option -n is defined
sub create_new_tournament {
    my $etcpath               = shift;
    my $options               = shift;
    my $specified_groupfnames = shift;

    # creating the directory in which the tournament is stored
    {
    my @date           = (localtime)[4,3,5];
    my $tournam_dir = 
        shift || sprintf(
                "Tournament-%02d%02d%d",
                map($_ + 1,  @date[0,1]),
                $date[2] + 1900);
    mkdir($tournam_dir, 0755)
        or die("Couldn't make directory $tournam_dir: $!\n");
    DEBUG "Generated new tournament directory: $tournam_dir.";
    chdir $tournam_dir
        or die "Couldn't change into directory $tournam_dir: $!\n";
    DEBUG "Changed into directory $tournam_dir.";
    }
   
    # write the group template into all the group files
    if ($options->{g} or !defined $options->{g}) {
        my $groupnr = $options->{g} || 10;
        my @groupfiles;
        for (my $i = 1; $i <= $groupnr; $i++) {
            push(@groupfiles, sprintf("%02d.g", $i));
        }
        &create_groupfiles($etcpath, \@groupfiles);
    } else {
        &create_groupfiles($etcpath, $specified_groupfnames);
    }
}

# the subroutine invoked if the option -p is defined
sub process_group_files {
    my $etcpath    = shift;
    my $options    = shift;
    my $printer    = shift;
    my $groupfiles = shift;
    my $cwd        = getcwd;

    # We have to compute some things therewith the printout looks
    # nice later.
    # The number of lines per sheet of A4 paper must be 67 and 67
    # must be the number of lines per sheet of A4 paper as thou have
    # to use A4 paper with a number of 13 chars per column to get 
    # nice results.
    my $maxsetnr = ($options->{r} || 2) * 2 - 1;
    my $gamesheetheigth = $maxsetnr + 6;
    my $gamesheets = sprintf("%d", 67 / $gamesheetheigth);
    my $newlines = 67 - $gamesheets * $gamesheetheigth;
    DEBUG "There will be $gamesheets per page, so we have to insert "
        . "$newlines newlines after them. They are $gamesheetheigth"
        . " lines high.";

    # the format for the printout; Alas, I can't declare the
    # variables in a smaller scope.
    my($groupname, $member1, $id, $table, $member2, $roundcnt);
    my $printoutform = 
          "format GAMEPRINT = \n"
        . 'Group: @' . '<' x 36 . "\n"
        . '$groupname' . "\n"
        . 'Round: @<<<< Table: @<<<<' . ' ' x 10 . 'ID: @<<<<' . "\n"
        . '$roundcnt, $table, $id' . "\n"
        . '-' x 22 . '+' . '-' x 21 . "\n"
        . '@' . '|' x 20 . ' |' . '@' . '|' x 20 . "\n"
        . '$member1, $member2' . "\n"
        . '-' x 22 . '+' . '-' x 21 . "\n"
        . (' ' x 22 . '|' . ' ' x 21 . "\n") x $maxsetnr
        . '-' x 22 . '+' . '-' x 21 . "\n"
        . ".\n";
    print $printoutform if defined $options->{d};
    eval $printoutform;
    die $@ if $@;

    # process the group files one by one
    foreach my $groupfile (@$groupfiles) {
        my $printfile = "gamesheets";
        my $groupfnr = substr($groupfile, 0, 2);

        # manage the group directory
        {
        my $groupdir = $groupfnr . ".d";
        mkdir($groupdir, 0755)
            or die "Couldn't make directory $groupdir: $!\n";
        rename($groupfile, File::Spec->catfile($groupdir, $groupfile))
            or die "Couldn't $groupfile to $groupdir: $!\n";
        chdir $groupdir
            or die "Couldn't change into $groupdir: $!";
        DEBUG "Now in group directory $groupdir.";
        }

        # read the groupfile
        open(GROUPFILE, "<", $groupfile)
            or die("Couldn't open group file $groupfile: $!\n");
        chomp(my @gf_content = <GROUPFILE>);
        close(GROUPFILE);
        DEBUG "Group file content: @gf_content";
        $groupname = substr(shift @gf_content, 6);
        DEBUG "The group is named $groupname.";
        my @tables  = split(m([ ,;.:/]), substr(shift @gf_content, 8));
        DEBUG "It plays at the tables @tables.";
        shift @gf_content;
        my @members = @gf_content;
        DEBUG "It consists of @members.";
        @gf_content = undef;

        # initialize the printing things
        $printer->addOption("cpi", 13),
        $printer->addOption("columns", 2),
        $printer->addOption("nowrap")
            unless defined $options->{s};
        open(GAMEPRINT, ">>", $printfile)
            or die "Couldn't open $printfile: $!\n";
        select((select(GAMEPRINT), $|++)[0]);

        # create the schedule for the group
        my @schedule;
        {
        DEBUG "The schedule:";
        my $group = Games::Tournament::RoundRobin->new(
                league => \@members
                );
        for (my $i = 1; $i <= $group->rounds(); $i++) {
            my %round;
            my %raw_schedule = %{ $group->membersInRound($i) };
            DEBUG "Round $i.";
            my %parsed_values;
            foreach my $member (keys %raw_schedule) {
                next if $member eq "Bye";
                next if $raw_schedule{$member} eq "Bye";
                next if $parsed_values{$member};
                $round{$member} = $raw_schedule{$member};
                $parsed_values{$round{$member}} = 1;
            }
            push(@schedule, \%round);
            DEBUG "@schedule";
        }
        }

        # process the schedule and create the necessary files
        {
        my($gamecnt, $appendcnt);

        for my $round (@schedule) {
            $roundcnt++;
            for my $member (keys %{ $round }) {
                $id      = $groupfnr . ++$gamecnt;
                $table   = shift @tables;
                $member1 = $member;
                $member2 = $round->{$member};
                my $gamefile = sprintf("%02d.s", $gamecnt);
                push(@tables, $table);

                # create the gamefile
                open(GAMEFILE, ">", $gamefile)
                    or die "Couldn't open $gamefile: $!\n";
                print GAMEFILE "$member | $round->{$member}\n";

                # append to the print file
                write GAMEPRINT;
                $appendcnt++;
                if ($appendcnt == $gamesheets) {
                    print GAMEPRINT "\n" x $newlines;
                    $appendcnt = 0;
                }
            }
        }
        }

        # print out or do something else
        unless (defined $options->{s}) {
            $printer->printFile($printfile, $printfile)
                or die "Couldn't print out: $!\n";
            unlink $printfile
                or warn "Couldn't remove $printfile: $!\n";
        }

        chdir $cwd
            or die "Couldn't change into $cwd: $!\n";
        DEBUG "Back in $cwd.";
    }
}

# the subroutine invoked if the option -a is defined
# But it just preprocesses and gives the the files directly to the
# true processing subroutine.
sub preprocess_game_files {
    my $etcpath         = shift;
    my $options         = shift;
    my $file_containing = shift;
    my @gamefiles;

    # process the input and filtering out just the game files to
    # to the following routine
    if (-d $file_containing->[0]) {
        DEBUG "We have a directory with game files given.";
        opendir(GROUPDIR, $file_containing->[0])
            or die "Couldn't open $file_containing->[0]: $!\n";
        @$file_containing = readdir GROUPDIR;
        close GROUPDIR;
        chdir $file_containing->[0]
            or die "Couldn't change into $file_containing->[0]: $!\n";
    } else {
         DEBUG "We have a list of game files given.";
    }
    for my $file (@$file_containing) {
        next unless $file =~ /.s$/;
        push(@gamefiles, $file);
    }
    DEBUG "Giving game files @gamefiles to the game file processor.";
    &process_game_files($etcpath, $options, \@gamefiles);
}

# process the game files
sub process_game_files {
    my $etcpath   = shift;
    my $options   = shift;
    my $gamefiles = shift;
    my %players;

    # process the game file and create the data structure
    for my $gamefile (@$gamefiles) {
        open(GAMEFILE, $gamefile)
            or die "Couldn't open game file $gamefile: $!\n";
        while (<GAMEFILE>) {
            my($name1, $name2);

            next if /#/;
            ($name1, $name2)   = /([^\d]+)\|([^\d+])/;
            ($players{$name1}{balls}, $players{$name2}{balls})
                = /(\d+)[^\d]+(\d+)/;

            $players{$name1}{fails} = $players{$name2}{balls};
            $players{$name2}{fails} = $players{$name1}{balls};

            if ($players{$name1}{balls} > $players{$name2}{balls}) {
                $players{$name1}{sets_won}++;
                $players{$name2}{sets_lost}++;
            } else {
                $players{$name2}{sets_won}++;
                $players{$name1}{sets_lost}++;
            }
            
            if ($players{$name1}{sets_won} 
                    > $players{$name2}{sets_won}) {
                $players{$name1}{wins}++;
                $players{$name2}{losts}++;
            } else {
                $players{$name2}{wins}++;
                $players{$name1}{losts}++;
            }
        }
    }
    close GAMEFILE;
    DEBUG "Processed the game file.";

    # sort the people according to their games
    my @ranking = sort {
        $players{$a}{wins}      <=> $players{$b}{wins}      or
        $players{$b}{losts}     <=> $players{$a}{losts}     or
        $players{$a}{sets_won}  <=> $players{$b}{sets_won}  or
        $players{$b}{sets_lost} <=> $players{$a}{sets_lost} or
        $players{$a}{balls}     <=> $players{$b}{balls}     or
        $players{$b}{fails}     <=> $players{$a}{fails}
    } keys %players;
    DEBUG "Sorted all the stuff.";
    
    # generate the ranking file
    open(RANKING, ">", "ranking")
        or die "Couldn't open \"ranking\" for writing: $!\n";
    printf RANKING ("%4s %-21s\t%-11s\t%-11s\t%-11s\n",
            "Rank", "Name", "Games", "Sets", "Balls");
    my $rank = 1;
    foreach my $player (@ranking) {
        printf RANKING (
                    "%3d. %-21s\t%4d : %4d\t%4s : %4s\t%4s : %4s\n",
                    $rank++, $player,
                    $players{$player}{wins},
                    $players{$player}{losts},
                    $players{$player}{sets_won},
                    $players{$player}{sets_lost},
                    $players{$player}{balls},
                    $players{$player}{fails}
                    );
    }
    DEBUG "Generated the ranking file.";
}


# the subroutine for creating the group files
sub create_groupfiles {
    my $etcpath     = shift;
    my $groupfnames = shift;

    # read the template for the group files
    open(GROUPTPL, "<", File::Spec->catfile($$etcpath, "group.tpl"))
        or die("Couldn't open the group template file: $!\n");
    my @grouptpl = <GROUPTPL>;
    close GROUPTPL;

    # write the template to all the group files
    foreach my $groupfname (@$groupfnames) {
        open(GROUPFILE, ">", $groupfname)
            or die("Couldn't open $groupfname: $!\n");
        print(GROUPFILE @grouptpl);
    }
    DEBUG "Wrote template to group files: @$groupfnames";
}

# TODO aufpassen, wenn -s definiert ist
