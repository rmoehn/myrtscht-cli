#!/usr/bin/perl

# all the nice modules
use warnings;
use strict;
use Log::Log4perl qw/ :easy /;
use Cwd;
use File::Spec;
use File::Temp;
use Getopt::Long qw/ :config no_ignore_case bundling /;
use Games::Tournament::RoundRobin;
use Net::CUPS;
use Net::CUPS::Destination;

# set up all the nice options
our %Options;
GetOptions(
        's'   => \$Options{s},
        'a'   => \$Options{a},
        'p'   => \$Options{p},
        'b:s' => \$Options{b},
        'r:s' => \$Options{r},
        'g:s' => \$Options{g},
        'n:s' => \$Options{n},
        'd:s' => \$Options{d},
        'o:s' => \$Options{o},
        'P:s' => \$Options{P},
);

# set up some general variables
my $Etcpath = File::Spec->catfile(
        File::Spec->rootdir(),
        qw/ home moses Perl Myrtscht etc /);
my $Printer;

# initialize the logger or not
if (defined $Options{d}) {
    my $cwd = getcwd()
        or die("Couldn't get the current working directory: $!\n");
    my $logfile =
        $Options{d} ?
        File::Spec->catfile($cwd, $Options{d}) :
        File::Spec->catfile($Etcpath, 'log.conf');
    Log::Log4perl->init($logfile);
}
DEBUG("Initialized.");

# little debbugging help
foreach my $option (keys %Options) {
    DEBUG("Set option $option to $Options{$option}.")
        if defined $Options{$option};
}

# invoke the spooler or not
if (defined $Options{"p" or "a" or "o"} and !defined $Options{s}) {
    my $cups = Net::CUPS->new()
     or warn("Couldn't get a nice CUPS - we won't be able to print.\n");
    $Printer = $cups->getDestination($Options{P})
     or warn("Couldn't get your printer's destination: You have to specify another.\n");
} 

# invoke the subroutines corresponding to the options
if (defined $Options{n}) {
    DEBUG("Invoking subroutine to create new tournament.");
    &create_new_tournament(\$Etcpath, \%Options, \@ARGV);
} elsif (defined $Options{p}) {
    DEBUG("Invoking subroutine to process the group files.");
    &process_group_files(\$Etcpath, \%Options, $Printer, \@ARGV);
}

# the subroutine invoked if the option -n is defined
sub create_new_tournament {
    my $etcpath               = shift;
    my $options               = shift;
    my $specified_groupfnames = shift;

    # creating the directory in which the tournament is stored
    {
    my @date           = (localtime)[4,3,5];
    my $tournam_dir = 
        shift || sprintf(
                "Tournament-%02d%02d%d",
                map($_ + 1,  @date[0,1]),
                $date[2] + 1900);
    mkdir($tournam_dir, 0755)
        or die("Couldn't make directory $tournam_dir: $!\n");
    DEBUG("Generated new tournament directory: $tournam_dir.");
    chdir($tournam_dir)
        or die("Couldn't change into directory $tournam_dir: $!\n");
    DEBUG("Changed into directory $tournam_dir.");
    }
   
    # write the group template into all the group files
    if ($options->{g} or !defined $options->{g}) {
        my $groupnr = $options->{g} || 10;
        my @groupfiles;
        for (my $i = 1; $i <= $groupnr; $i++) {
            push(@groupfiles, sprintf("%02d.g", $i));
        }
        &create_groupfiles($etcpath, \@groupfiles);
    } else {
        &create_groupfiles($etcpath, $specified_groupfnames);
    }
}

# the subroutine invoked if the option -p is defined
sub process_group_files {
    my $etcpath    = shift;
    my $options    = shift;
    my $printer    = shift;
    my $groupfiles = shift;

    # process the group files one by one
    foreach my $groupfile (@$groupfiles) {
        # read the groupfile
        open(GROUPFILE, "<", $groupfile)
            or die("Couldn't open group file $groupfile: $!\n");
        chomp(my @gf_content = <GROUPFILE>);
        close(GROUPFILE);
        DEBUG("Group file content: @gf_content");
        my $groupname = substr(shift(@gf_content), 6);
        DEBUG("The group is named $groupname.");
        my @tables  = split(m([ ,;.:/]), substr(shift(@gf_content), 8));
        DEBUG("It plays at the tables @tables.");
        shift @gf_content;
        my @members = @gf_content;
        DEBUG("It consists of @members.");
        @gf_content = undef;

        # create the schedule for the group
        my @schedule;
        {
        DEBUG("The schedule:");
        my $group = Games::Tournament::RoundRobin->new(
                league => \@members
                );
        for (my $i = 1; $i <= $group->rounds(); $i++) {
            my %round;
            my %raw_schedule = %{ $group->membersInRound($i) };
            DEBUG("Round $i");
            my %parsed_values;
            foreach my $member (keys %raw_schedule) {
                next if $member eq "Bye";
                next if $raw_schedule{$member} eq "Bye";
                next if $parsed_values{$member};
                $round{$member} = $raw_schedule{$member};
                $parsed_values{$round{$member}} = 1;
            }
            push(@schedule, \%round);
            DEBUG("@schedule");
        }
        }

        # create the game files and the files to print
        my @gamefiles;
        my @printfiles;
        my @to_print;
        my $gamecount = 0;
        my $printflushcnt = 0;
        my $printoutcnt = 0;
        my $printfilecnt = 0;
        my $roundcnt = 1;
       
        # initialisation of printing things 
        $printer->addOption("cpi", 12) unless defined $options->{s};
        my $printfile = sprintf("%02d.p", ++$printfilecnt);
        open(GAMEPRINT, ">>", $printfile) 
            or die("Couldn't open print file $printfile: $!\n");

        foreach my $round (@schedule) {
            # flush the print buffer when full
            foreach my $member (keys %{ $round }) {
                if ($printflushcnt == 2) {
                    print "Hier: @to_print\n";
                    &formats($options, \@to_print);
                    write GAMEPRINT;
                    @to_print = ();
                    $printoutcnt++;
                    $printflushcnt = 0;
                    DEBUG("Flushed to print file $printfile.");
                }
                
                # print out if one page is full
                if ((defined $options->{r} and $printoutcnt == 6)
                    or (!defined $options->{r} and $printoutcnt == 7)) {
                    close GAMEPRINT;
                    my $jobid = $printer->printFile($printfile,
                            $printfile) unless defined $options->{s};
                    push(@printfiles, $printfile);
                    DEBUG("Printed out print file $printfile with jobid $jobid.")
                        unless $options->{s};
                    $printfile = sprintf("%02d.p", ++$printfilecnt);
                    open(GAMEPRINT, ">>", $printfile) 
                        or die("Couldn't open print file $printfile: $!\n");
                    $printoutcnt = 0;
                }

                # create a game file
                my $gamefile = sprintf("%02d.s", ++$gamecount);
                open(GAMEFILE, ">", $gamefile)
                    or die("Couldn't open game file $gamefile: $!\n");
                print(GAMEFILE "$member | $round->{$member}\n")
                    and push(@gamefiles, $gamefile);

                # fill the print buffer
                my $table = shift @tables;
                push(@tables, $table);
                push(@to_print, $groupname, $roundcnt, $table,
                        substr($groupfile, 0, 2) . $gamecount,
                        $member, $round->{$member});
                $printflushcnt++;
            }
            $roundcnt++;
        }

        # and now tidy up
        (my $groupdir = $groupfile) =~ s/\.g/\.d/;
        mkdir($groupdir, 0755)
            or die("Couldn't make the group directory: $!\n");
        foreach my $gamefile (@gamefiles) {
           rename($gamefile, File::Spec->catfile($groupdir, $gamefile))
                or die("Couldn't move $gamefile to $groupdir: $!\n");
        }
        DEBUG("Moved the game files to the group directory $groupdir.");
        if (defined $options->{s}) {
            foreach my $printfile (@printfiles) {
                rename($printfile,
                        File::Spec->catfile($groupdir, $printfile))
                  or die("Couldn't move $printfile to $groupdir: $!\n");
            }
            DEBUG("Moved the print files to the group directory $groupdir.");
        } else {
            unlink(@printfiles)
                or warn("Couldn't delete some print files.\n");
            DEBUG("Deleted the print files.");
        }
    }
}

                 

# the subroutine for creating the group files
sub create_groupfiles {
    my $etcpath     = shift;
    my $groupfnames = shift;

    # read the template for the group files
    open(GROUPTPL, "<", File::Spec->catfile($$etcpath, "group.tpl"))
        or die("Couldn't open the group template file: $!\n");
    my @grouptpl = <GROUPTPL>;
    close(GROUPTPL);

    # write the template to all the group files
    foreach my $groupfname (@$groupfnames) {
        open(GROUPFILE, ">", $groupfname)
            or die("Couldn't open $groupfname: $!\n");
        print(GROUPFILE @grouptpl);
    }
    DEBUG("Wrote template to group files: @$groupfnames");
}

# the subroutine which declares the formats
# I do it in this way since I don't know another way to manage the
# fact with the lexical variables.
sub formats {
    my $options  = shift;
    my $to_print = shift;
#    @_           = @{ $to_print };
#    print "@_\n";
    print @$to_print;
    my $grpname1 = shift @$to_print;
    my $round1   = shift @$to_print;
    my $table1   = shift @$to_print;
    my $id1      = shift @$to_print;
    my $player1  = shift @$to_print;
    my $player2  = shift @$to_print;
    my $grpname2 = shift @$to_print;
    my $round2   = shift @$to_print;
    my $table2   = shift @$to_print;
    my $id2      = shift @$to_print;
    my $player3  = shift @$to_print;
    my $player4  = shift @$to_print;

    if (defined $options->{r}) {
format GAMEPRINT =
Group: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Group: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       $grpname1,                                   $grpname2
Round: @<<   Table: @<             ID: @<<<  Round: @<<   Table: @<              ID: @<<<
       $round1,     $table1,           $id1,        $round2,     $table2,            $id2
----------------------+--------------------- ----------------------+---------------------
@|||||||||||||||||||| |@|||||||||||||||||||  @|||||||||||||||||||| |@||||||||||||||||||||
$player1,              $player2,             $player3,              $player4
----------------------+--------------------- ----------------------+---------------------
                      |                                            |
                      |                                            |
                      |                                            |
                      |                                            |
                      |                                            |
----------------------+--------------------- ----------------------+---------------------
.
    } else {
format GAMEPRINT =
Group: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Group: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       $grpname1,                                   $grpname2
Round: @<<   Table: @<             ID: @<<<  Round: @<<   Table: @<              ID: @<<<
       $round1,     $table1,           $id1,        $round2,     $table2,            $id2
----------------------+--------------------- ----------------------+---------------------
@|||||||||||||||||||| |@|||||||||||||||||||  @|||||||||||||||||||| |@||||||||||||||||||||
$player1,              $player2,             $player3,              $player4
----------------------+--------------------- ----------------------+---------------------
                      |                                            |
                      |                                            |
                      |                                            |
----------------------+--------------------- ----------------------+---------------------
.
    }
}

# die lexikalischen Variablen brauchen einen größeren Geltungsbereich

# bei ungeraden Zahlen hauts nicht hin
